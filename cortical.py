# -*- coding: utf-8 -*-
#
# 3Play Media: Cambridge, MA, USA
# support@3playmedia.com
#
# Copyright (c) 2012 3Play Media, Inc.  The following software is the sole and
# exclusive property of 3Play Media, Inc. and may not to be reproduced,
# modified, distributed or otherwise used, without the written approval
# of 3Play Media, Inc.
#
# This software is provided "as is" and any express or implied
# warranties, including but not limited to, an implied warranty of
# merchantability and fitness for a particular purpose are disclaimed.
#
# In no event shall 3Play Media, Inc. be liable for any direct,
# indirect, incidental, special, exemplary, or consequential damages
# (including but not limited to, procurement or substitute goods or
# services, loss of use, data or profits, or business interruption)
# however caused and on any theory of liability, whether in contract,
# strict liability, or tort (including negligence or otherwise) arising
# in any way out of the use of this software, even if advised of the
# possibility of such damage.

import numpy as np
# - some functions adapted from gen_cort.m by Powen Ru (powen@isr.umd.edu), NSL, UMD

def filter(specgram, rates=[1, 2, 4, 8, 16, 32], scales=[0.5, 1, 2, 4, 8], fl=8, tc=8, fac=-2, shift=0, full_T=0, full_X=0, BP=0):
    """
    AUD2COR (forward) cortical rate-scale representation
    cr = aud2cor(y, para1, rv, sv, fname, DISP);
    cr    : cortical representation (4D, scale-rate(up-down)-time-freq.)
    y    : auditory spectrogram, N-by-M, where
    N = # of samples, M = # of channels
    para1 = [paras FULLT FULLX BP]
    paras    : [frmlen, tc, fac, shft] => frame length, time const, non-linear factor, fs octave shift
    FULLT (FULLX): fullness of temporal (spectral) margin. The value can
    be any real number within [0, 1]. If only one number was
    assigned, FULLT = FULLX will be set to the same value.
    BP    : pure bandpass indicator
    rv    : rate vector in Hz, e.g., 2.^(1:.5:5).
    sv    : scale vector in cyc/oct, e.g., 2.^(-2:.5:3).

    AUD2COR implements the 2-D wavelet transform
    possibly executed by the A1 cortex. The auditory
    spectrogram (Y) is the output generated by the 
    cochlear model (WAV2AUD) according to the parameter
    set PARA1. RV (SV) is the characteristic frequencies
    (ripples) of the temporal (spatial) filters. This
    function will store the output in a file with a
    conventional extension .COR. Roughly, one-second
    signal needs about 22 MB if 8-ms-frame is adopted.
    Choosing truncated fashion (FULL = 0) will reduce
    the size to 1/4, which will also reduce runing time
    to half.
    See also: WAV2AUD, COR_INFO, CORHEADR, COR_RST
    """

    K1 = len(rates)
    K2 = len(scales)
    (N, M) = specgram.shape

    N1 = int(2**np.ceil(np.log2(N)))
    N2 = 2*N1
    M1 = int(2**np.ceil(np.log2(M)))
    M2 = 2*M1

    # 2D FT of specgram to perform rate/scale filter in secgram-freq domain
    Y = np.fft.rfft2(specgram,s=(N2,M2))[:,0:M1]

    STF = 1000.0 / fl    # frame per second
    SRF = 24        # channel per octave (fixed)

    # freq. index
    dM   = int(float(M)/2*full_X)
    mdx1 = np.hstack((np.arange(dM)+M2-dM, np.arange(M)+dM))

    # temp. index
    dN   = int(float(N)/2*full_T)
    ndx  = np.arange(N)+2*dN
    ndx1 = ndx

    z  = np.zeros((N+2*dN, M+2*dM), dtype='complex128')
    cr = np.zeros((K2, K1*2, N+2*dN, M+2*dM), dtype='complex128')

    for rdx in xrange(K1):
        # rate filtering
        fc_rt = rates[rdx]
        HR = temporal_filter(fc_rt, N1, STF, [1+rdx+BP, K1+BP*2])

        for sgn in (1, -1):
            # rate filtering modification
            if sgn > 0:
                HR = np.hstack((HR, np.zeros(N1)))
            else:
                HR = np.hstack( (HR[0], np.conj(HR[N2:0:-1])) )
                if N2 > 2:
                	HR[N1] = np.abs(HR[N1+1])
        
            # first inverse fft (w.r.t. time axis)
            z1 = HR[:,None] * Y
            z1 = np.fft.ifft(z1,axis=0)
            z1 = z1[ndx1,:]
        
            for sdx in xrange(K2):
                # scale filtering
                fc_sc = scales[sdx]
                HS = frequency_filter(fc_sc, M1, SRF, [1+sdx+BP, K2+BP*2])
            
                # second inverse fft (w.r.t frequency axis)
                z[ndx,:] = np.fft.ifft(z1*HS,axis=1,n=M2)[ndx[:,None],mdx1]
                cr[sdx, rdx+(sgn==1)*K1, :, :] = z

    return cr


def temporal_filter(fc, L, srt, PASS = [2,3]):
    """Generate (bandpass) cortical filter transfer function
    fc: characteristic frequency
    L: filter length (use power of 2)
    srt: sample rate
    PASS: (vector) [idx K]
    idx = 1, lowpass; 1<idx<K, bandpass; idx = K, highpass.

    GEN_CORT generate (bandpass) cortical temporal filter for various
    length and sampling rate. The primary purpose is to generate 2, 4,
    8, 16, 32 Hz bandpass filter at sample rate ranges from, roughly
    speaking, 65 -- 1000 Hz. Note the filter is complex and non-causal.
    see also: AUD2COR, COR2AUD, MINPHASE
    """

    t = np.arange(L).astype(np.float)/srt
    k = t*fc
    h = np.sin(2*np.pi*k) * k**2 * np.exp(-3.5*k) * fc

    h = h-np.mean(h)
    H0 = np.fft.fft(h, n=2*L)
    A = np.angle(H0[0:L])
    H = np.abs(H0[0:L])
    maxi = np.argmax(H)
    H = H / (H[maxi] or 1)

    # passband
    if PASS[0] == 1:
        #low pass
        H[0:maxi] = 1
    elif PASS[0] == PASS[1]:
        #high pass
        H[maxi+1:L] = 1

    H = H * np.exp(1j*A)
    return H

def frequency_filter(fc, L, srf, KIND=2):
    """
    GEN_CORF generate (bandpass) cortical filter transfer function
    h = gen_corf(fc, L, srf);
    h = gen_corf(fc, L, srf, KIND);
    fc: characteristic frequency
    L: length of the filter, power of 2 is preferable.
    srf: sample rate.
    KIND: (scalar)
          1 = Gabor function; (optional)
          2 = Gaussian Function (Negative Second Derivative) (defualt)
          (vector) [idx K]
          idx = 1, lowpass; 1<idx<K, bandpass; idx = K, highpass.

    GEN_CORF generate (bandpass) cortical filter for various length and
    sampling rate. The primary purpose is to generate 2, 4, 8, 16, 32 Hz
    bandpass filter at sample rate 1000, 500, 250, 125 Hz. This can also
    be used to generate bandpass spatial filter .25, .5, 1, 2, 4 cyc/oct
    at sample ripple 20 or 24 ch/oct. Note the filter is complex and
    non-causal.
    see also: AUD2COR, COR2AUD
    """

    if hasattr(KIND, "__len__"):
        PASS = KIND
        KIND = 2
    else:
        PASS = [2,3]
        KIND = [KIND]

    # fourier transform of lateral inhibitory function 

    # tonotopic axis
    R1    = np.arange(L).astype(np.float)/L*srf/2/np.abs(fc)

    if KIND == 1:
        # Gabor function
        C1      = 1./2/0.3/0.3
        H       = np.exp(-C1*(R1-1)**2) + np.exp(-C1*(R1+1)**2)
    else:
        # Gaussian Function
        R1    = R1 ** 2
        H    = R1 * np.exp(1-R1)

    # passband
    if PASS[0] == 1:
        #lowpass
        maxi = np.argmax(H)
        sumH = H.sum()
        H[0:maxi] = 1
        H = H / (H.sum()  or 1) * sumH
    elif PASS[0] == PASS[1]:
        # highpass
        maxi = np.argmax(H)
        sumH = H.sum()
        H[maxi+1:L] = 1
        H = H / (H.sum() or 1) * sumH

    return H